// what make dumps
c++ -O3 -std=c++17 -I /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/distrib/include/ -I /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/distrib/tools/  -Wall -Werror -Wno-unused-function -Wcast-qual -Wignored-qualifiers -Wno-comment -Wsign-compare -Wno-unknown-warning-option -Wno-psabi  -fvisibility=hidden halide_blur_generator.cpp /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/distrib/tools/GenGen.cpp -o bin/host/halide_blur.generator /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/distrib/lib/libHalide.a -L/usr/local/opt/llvm@14/lib -ldl -lpthread -lz -lzstd

bin/host/halide_blur.generator -g halide_blur -e static_library,h,registration,stmt,assembly,c_source -o bin/host target=host

c++ -O3 -std=c++17 -I /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/distrib/include/ -I /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/distrib/tools/  -Wall -Werror -Wno-unused-function -Wcast-qual -Wignored-qualifiers -Wno-comment -Wsign-compare -Wno-unknown-warning-option -Wno-psabi  -fvisibility=hidden  -Wall -O2 -Ibin/host test.cpp bin/host/halide_blur.a -o bin/host/test -L/usr/local/opt/llvm@14/lib -ldl -lpthread -lz -lzstd
ld: warning: no platform load command found in 'bin/host/halide_blur.a[2](halide_blur.a.o)', assuming: macOS
rm bin/host/halide_blur.a



// to run the test
bin/host/test

// end of what make dumps


// c_source generated by halide using
bin/host/halide_blur.generator -g halide_blur -e assembly,bitcode,c_header,c_source,cpp_stub,featurization,llvm_assembly,object,python_extension,pytorch_wrapper,registration,schedule,static_library,stmt,stmt_html,compiler_log -o bin/host target=host
// this was after running make which generated /Users/ardimadadi/Documents/Projects/Studies/Research/halide/Halide_latest/apps/blur/bin/host/halide_blur.halide_generated.cpp

// demangled c++ code

int halide_default_do_par_for(void *user_context, halide_task_t f,
                              int min, int size, uint8_t *closure) {
    for (int x = min; x < min + size; x++) {
        int result = halide_do_task(user_context, f, x, closure);
        if (result) {
            return result;
        }
    }
    return 0;
}

halide_do_par_for_t custom_do_par_for = halide_default_do_par_for;
extern int halide_do_par_for(void *user_context, halide_task_t f,
                             int min, int size, uint8_t *closure) {
    return (*custom_do_par_for)(user_context, f, min, size, closure);
}

void *aligned_malloc(size_t alignment, size_t size) {
    // We also need to align the size of the buffer.
    size = (size + alignment - 1) & ~(alignment - 1);

    // Allocate enough space for aligning the pointer we return.
    void *orig = malloc(size + alignment);
    if (orig == nullptr) {
        // Will result in a failed assertion and a call to halide_error
        return nullptr;
    }
    // We want to store the original pointer prior to the pointer we return.
    void *ptr = (void *)(((size_t)orig + alignment + sizeof(void *) - 1) & ~(alignment - 1));
    ((void **)ptr)[-1] = orig;
    return ptr;
}

static const int num_buffers = 10;
static const int buffer_size = 1024 * 64;
int buf_is_used[num_buffers];
void *mem_buf[num_buffers] = {
    nullptr,
};

void *halide_default_malloc(void *user_context, size_t x) {
    // Hexagon needs up to 128 byte alignment.
    const size_t alignment = 128;

    if (x <= buffer_size) {
        for (int i = 0; i < num_buffers; ++i) {
            if (__sync_val_compare_and_swap(buf_is_used + i, 0, 1) == 0) {
                if (mem_buf[i] == nullptr) {
                    mem_buf[i] = aligned_malloc(alignment, buffer_size);
                }
                return mem_buf[i];
            }
        }
    }

    return aligned_malloc(alignment, x);
}
void aligned_free(void *ptr) {
    if (ptr) {
        free(((void **)ptr)[-1]);
    }
}
void halide_default_free(void *user_context, void *ptr) {
    for (int i = 0; i < num_buffers; ++i) {
        if (mem_buf[i] == ptr) {
            buf_is_used[i] = 0;
            return;
        }
    }

    aligned_free(ptr);
}

void *halide_malloc(void *user_context, size_t x) {
    return halide_default_malloc(user_context, x);
}
void halide_print(void *user_context, const char *str) {
    std::cout << str;
}

void halide_free(void *user_context, void *ptr) {
    halide_default_free(user_context, ptr);
}


int halide_error_out_of_memory(void *user_context) {
    // The error message builder uses malloc, so we can't use it here.
    halide_error(user_context, "Out of memory (halide_malloc returned nullptr)");
    return halide_error_code_out_of_memory;
}
int halide_error_device_dirty_with_no_device_support(void *user_context, const char *func) {
    std::cerr
        << "The buffer " << func
        << " is dirty on device, but this pipeline was compiled "
        << "with no support for device to host copies.";
    return halide_error_code_device_dirty_with_no_device_support;
}

int halide_error_host_is_null(void *user_context, const char *func) {
    std::cerr
        << "The host pointer of " << func
        << " is null, but the pipeline will access it on the host.";
    return halide_error_code_host_is_null;
}
int halide_error_constraint_violated(void *user_context, const char *var, int val,
                                     const char *constrained_var, int constrained_val) {
    std::cerr << "Constraint violated: " << var << " (" << val
              << ") == " << constrained_var << " (" << constrained_val << ")";
    return halide_error_code_constraint_violated;
}
int halide_error_buffer_argument_is_null(void *user_context, const char *buffer_name) {
    std::cerr
        << "Buffer argument " << buffer_name << " is nullptr";
    return halide_error_code_buffer_argument_is_null;
}
int halide_error_bad_type(void *user_context, const char *func_name,
                          uint32_t type_given_bits, uint32_t correct_type_bits) {
    halide_type_t correct_type, type_given;
    memcpy(&correct_type, &correct_type_bits, sizeof(uint32_t));
    memcpy(&type_given, &type_given_bits, sizeof(uint32_t));
    std::cerr
        << func_name << " has type ";
    return halide_error_code_bad_type;
}
int halide_error_buffer_allocation_too_large(void *user_context, const char *buffer_name, uint64_t allocation_size, uint64_t max_size) {
    std::cerr
        << "Total allocation for buffer " << buffer_name
        << " is " << allocation_size
        << ", which exceeds the maximum size of " << max_size;
    return halide_error_code_buffer_allocation_too_large;
}

int halide_error_buffer_extents_negative(void *user_context, const char *buffer_name, int dimension, int extent) {
    std::cerr
        << "The extents for buffer " << buffer_name
        << " dimension " << dimension
        << " is negative (" << extent << ")";
    return halide_error_code_buffer_extents_negative;
}

int halide_error_buffer_extents_too_large(void *user_context, const char *buffer_name, int64_t actual_size, int64_t max_size) {
    std::cerr
        << "Product of extents for buffer " << buffer_name
        << " is " << actual_size
        << ", which exceeds the maximum size of " << max_size;
    return halide_error_code_buffer_extents_too_large;
}
int halide_error_bad_dimensions(void *user_context, const char *func_name,
                                int32_t dimensions_given, int32_t correct_dimensions) {
    std::cerr
        << func_name << " requires a buffer of exactly " << correct_dimensions
        << " dimensions, but the buffer passed in has " << dimensions_given << " dimensions";
    return halide_error_code_bad_dimensions;
}
int halide_error_access_out_of_bounds(void *user_context, const char *func_name,
                                      int dimension, int min_touched, int max_touched,
                                      int min_valid, int max_valid) {
    if (min_touched < min_valid) {
        std::cerr
            << func_name << " is accessed at " << min_touched
            << ", which is before the min (" << min_valid
            << ") in dimension " << dimension;
    } else if (max_touched > max_valid) {
        std::cerr
            << func_name << " is accessed at " << max_touched
            << ", which is beyond the max (" << max_valid
            << ") in dimension " << dimension;
    }
    return halide_error_code_access_out_of_bounds;
}
// This is a basic implementation of the Halide runtime for Hexagon.
void halide_error(void *user_context, const char *str) {
    halide_print(user_context, str);
}

int halide_default_do_task(void *user_context, halide_task_t f, int idx,
                           uint8_t *closure) {
    return f(user_context, idx, closure);
}
halide_do_task_t custom_do_task = halide_default_do_task;
int halide_do_task(void *user_context, halide_task_t f, int idx,
                   uint8_t *closure) {
    return (*custom_do_task)(user_context, f, idx, closure);
}

int halide_error_explicit_bounds_too_small(void *user_context, const char *func_name, const char *var_name,
                                                int min_bound, int max_bound, int min_required, int max_required) {
    std::cerr
        << "Bounds given for " << var_name << " in " << func_name
        << " (from " << min_bound << " to " << max_bound
        << ") do not cover required region (from " << min_required
        << " to " << max_required << ")";
    return halide_error_code_explicit_bounds_too_small;
}


// running mull_runner


// start of dumping llvm ir and other representations for mutatoons


